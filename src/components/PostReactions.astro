---
import { cn } from '@/lib/utils'

interface Props {
  postId: string
  className?: string
}

const { postId, className } = Astro.props
---

<section
  class={cn('flex flex-col gap-3', className)}
  aria-label="Post reactions"
>
  <div class="flex flex-wrap items-center gap-2">
    <button
      type="button"
      data-reaction="clap"
      data-post-id={postId}
      class="group relative flex items-center gap-2 rounded-full bg-muted/60 px-4 py-2 text-sm transition-all hover:bg-muted focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:opacity-60 disabled:cursor-not-allowed"
      aria-label="React with clap"
      title="Clap"
    >
      <span class="text-lg leading-none" aria-hidden="true">üëè</span>
      <span class="text-xs font-semibold text-foreground" data-count="clap-count">0</span>
    </button>
  </div>
</section>

<script lang="ts">
  /**
   * Clap-only reactions
   * Logic adapted from merox-main PostReactions (fetch counts, single reaction lock, localStorage tracking)
   */
  ;(() => {
    'use strict'

    const USER_REACTIONS_KEY = 'user-post-reactions'
    const API_BASE = '/api/reactions'

    type ReactionKey = string
    type ReactionCounts = Record<ReactionKey, number>
    type ReactionButton = HTMLButtonElement
    type ReactionTimeout = ReturnType<typeof setTimeout>
    type ReactionResponse = {
      reactions?: ReactionCounts
      count?: number
    }

    let reactionButtons: ReactionButton[] = []
    let timeoutId: ReactionTimeout | null = null
    let scaleTimeoutIds: Map<ReactionButton, ReactionTimeout> = new Map()
    const processingButtons = new Set<ReactionButton>()
    let serverReactions: ReactionCounts = {}
    let currentPostId: string | null = null

    function getUserReactions(): Record<string, ReactionKey[]> {
      try {
        const stored = localStorage.getItem(USER_REACTIONS_KEY)
        return stored ? JSON.parse(stored) : {}
      } catch {
        return {}
      }
    }

    function hasUserReacted(postId: string): boolean
    function hasUserReacted(postId: string, reactionKey: ReactionKey): boolean
    function hasUserReacted(
      postId: string,
      reactionKey?: ReactionKey,
    ): boolean {
      const userReactions = getUserReactions()
      const postReactions = userReactions[postId] || []
      if (reactionKey) return postReactions.includes(reactionKey)
      return postReactions.length > 0
    }

    function markUserReacted(postId: string, reactionKey: ReactionKey): void {
      const userReactions = getUserReactions()
      if (!userReactions[postId]) {
        userReactions[postId] = []
      }
      if (!userReactions[postId].includes(reactionKey)) {
        userReactions[postId].push(reactionKey)
        try {
          localStorage.setItem(USER_REACTIONS_KEY, JSON.stringify(userReactions))
        } catch (err) {
          console.warn('Failed to save user reactions', err)
        }
      }
    }

    async function fetchReactionCounts(postId: string): Promise<void> {
      try {
        const response = await fetch(`${API_BASE}/${postId}`)
        if (!response.ok) {
          console.warn('Failed to fetch reaction counts:', response.statusText)
          return
        }
        const data = (await response.json()) as ReactionResponse
        serverReactions = data.reactions ?? {}

        if (reactionButtons.length > 0) {
          reactionButtons.forEach((button: ReactionButton) => {
            const reactionKey = button.dataset.reaction as ReactionKey | undefined
            if (reactionKey) {
              const count = serverReactions[reactionKey] ?? 0
              const countElement =
                button.querySelector('[data-count]')
              if (countElement) {
                countElement.textContent = count.toString()
              }
            }
          })
        }
      } catch (error) {
        console.error('Error fetching reaction counts:', error)
      }
    }

    function getReactionCount(reactionKey: ReactionKey): number {
      return serverReactions[reactionKey] || 0
    }

    async function incrementReaction(
      postId: string,
      reactionKey: ReactionKey,
    ): Promise<number | null> {
      if (hasUserReacted(postId)) return null
      try {
        const response = await fetch(`${API_BASE}/${postId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reactionKey }),
        })

        if (!response.ok) {
          console.error('Failed to update reaction:', response.statusText)
          return null
        }

        const data = (await response.json()) as ReactionResponse
        serverReactions = data.reactions ?? {}
        markUserReacted(postId, reactionKey)

        return data.count ?? serverReactions[reactionKey] ?? 0
      } catch (error) {
        console.error('Error updating reaction:', error)
        return null
      }
    }

    function updateReactionDisplay(
      button: ReactionButton,
      count: number,
      isReacted = false,
    ): void {
      const countElement = button.querySelector('[data-count]')
      if (countElement) {
        countElement.textContent = count.toString()
      }

      if (isReacted) {
        button.disabled = true
        button.classList.add('opacity-60', 'cursor-not-allowed')
        button.classList.remove('hover:bg-muted')
        button.setAttribute(
          'aria-label',
          (button.getAttribute('aria-label') || '') + ' (already reacted)',
        )
      } else {
        button.disabled = false
        button.classList.remove('opacity-60', 'cursor-not-allowed')
        button.classList.add('hover:bg-muted')
      }

      if (!isReacted) {
        const existingTimeout = scaleTimeoutIds.get(button)
        if (existingTimeout) clearTimeout(existingTimeout)
        button.classList.add('scale-105')
        const scaleTimeout = setTimeout(() => {
          button.classList.remove('scale-105')
          scaleTimeoutIds.delete(button)
        }, 200)
        scaleTimeoutIds.set(button, scaleTimeout)
      }
    }

    async function initializeReactionCounts(): Promise<void> {
      if (!currentPostId || reactionButtons.length === 0) return

      await fetchReactionCounts(currentPostId)

      reactionButtons.forEach((button: ReactionButton) => {
        const postId = button.dataset.postId || ''
        const reactionKey = button.dataset.reaction as ReactionKey | undefined

        if (!postId || !reactionKey) return

        const count = getReactionCount(reactionKey)
        const hasReacted = hasUserReacted(postId)
        updateReactionDisplay(button, count, hasReacted)
      })
    }

    async function handleReactionClick(e: Event): Promise<void> {
      const button = e.currentTarget as ReactionButton | null
      if (!button) return

      const postId = button.dataset.postId
      const reactionKey = button.dataset.reaction as ReactionKey | undefined

      if (!postId || !reactionKey) return

      if (processingButtons.has(button)) {
        e.preventDefault()
        return
      }

      if (hasUserReacted(postId)) {
        e.preventDefault()
        updateReactionDisplay(button, getReactionCount(reactionKey), true)
        return
      }

      e.preventDefault()
      processingButtons.add(button)
      button.disabled = true

      const newCount = await incrementReaction(postId, reactionKey)

      if (newCount !== null) {
        updateReactionDisplay(button, newCount, true)

        if (reactionButtons.length > 0) {
          reactionButtons.forEach((otherButton: ReactionButton) => {
            const otherPostId = otherButton.dataset.postId
            const otherReactionKey =
              otherButton.dataset.reaction as ReactionKey | undefined

            if (otherPostId && otherReactionKey && otherPostId === postId) {
              const otherCount = getReactionCount(otherReactionKey)
              const countElement =
                otherButton.querySelector('[data-count]')
              if (countElement) {
                countElement.textContent = otherCount.toString()
              }

              if (otherReactionKey !== reactionKey) {
                otherButton.disabled = true
                otherButton.classList.add('opacity-60', 'cursor-not-allowed')
                otherButton.classList.remove('hover:bg-muted')
              }
            }
          })
        }
      } else {
        button.disabled = true
        const count = getReactionCount(reactionKey)
        updateReactionDisplay(button, count, true)
      }

      setTimeout(() => {
        processingButtons.delete(button)
      }, 300)
    }

    function initReactions(): void {
      if (reactionButtons.length > 0) {
        reactionButtons.forEach((button: ReactionButton) => {
          button.removeEventListener('click', handleReactionClick)
        })
      }

      const buttonNodes = document.querySelectorAll<HTMLButtonElement>(
        'button[data-reaction][data-post-id]',
      )
      reactionButtons = Array.from(buttonNodes) as ReactionButton[]

      if (reactionButtons.length === 0) return

      const firstButton = reactionButtons[0]
      currentPostId = firstButton.dataset.postId || null

      if (!currentPostId) {
        console.error('Post ID not found')
        return
      }

      reactionButtons.forEach((button: ReactionButton) => {
        button.addEventListener('click', handleReactionClick)
      })

      initializeReactionCounts()
    }

    function cleanup(): void {
      if (timeoutId) {
        clearTimeout(timeoutId)
        timeoutId = null
      }

      scaleTimeoutIds.forEach((timeout: ReactionTimeout) => {
        clearTimeout(timeout)
      })
      scaleTimeoutIds.clear()

      if (reactionButtons.length > 0) {
        reactionButtons.forEach((button: ReactionButton) => {
          button.removeEventListener('click', handleReactionClick)
        })
        reactionButtons = []
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initReactions)
    } else {
      initReactions()
    }

    document.addEventListener('astro:page-load', () => {
      cleanup()
      timeoutId = setTimeout(initReactions, 0)
    })

    document.addEventListener('astro:before-swap', cleanup)
  })()
</script>
