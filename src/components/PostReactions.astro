---
import { cn } from '@/lib/utils'

interface Props {
  postId: string
  className?: string
}

const { postId, className } = Astro.props

// Emoji reactions with labels - keeping the 5 most useful ones
const reactions = [
  { emoji: 'üëç', label: 'Like', key: 'like' },
  { emoji: '‚ù§Ô∏è', label: 'Love', key: 'love' },
  { emoji: 'üî•', label: 'Fire', key: 'fire' },
  { emoji: 'üéâ', label: 'Celebrate', key: 'celebrate' },
  { emoji: 'üëè', label: 'Clap', key: 'clap' },
] as const

---

<section
  class={cn('flex flex-col gap-3', className)}
  aria-label="Post reactions"
>
  <h3 class="text-sm font-semibold text-muted-foreground">
    How did you like this post?
  </h3>
  <div class="flex flex-wrap items-center gap-2">
    {
      reactions.map((reaction) => (
        <button
          type="button"
          data-reaction={reaction.key}
          data-post-id={postId}
          class="group relative flex items-center gap-1.5 rounded-lg border border-border bg-background px-3 py-2 text-sm transition-all hover:bg-muted hover:border-primary/50 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed"
          aria-label={`React with ${reaction.label}`}
          title={reaction.label}
        >
          <span class="text-lg leading-none" aria-hidden="true">
            {reaction.emoji}
          </span>
          <span
            class="text-xs font-medium text-muted-foreground group-hover:text-foreground transition-colors"
            data-count={`${reaction.key}-count`}
          >
            0
          </span>
        </button>
      ))
    }
  </div>
</section>

<script>
  /**
   * Post Reactions Component - Best Practices Implementation
   * - Fetches reaction counts from server (centralized)
   * - Uses localStorage only to track user's own reactions (prevent duplicates)
   * - Syncs with server on reaction click
   * - Proper event delegation
   * - Clean event listener management
   * - Accessible and keyboard-friendly
   */
  (function () {
    'use strict'

    const USER_REACTIONS_KEY = 'user-post-reactions'
    const API_BASE = '/api/reactions'
    let reactionButtons: NodeListOf<HTMLButtonElement> | null = null
    let clickHandler: ((e: Event) => void) | null = null
    let timeoutId: ReturnType<typeof setTimeout> | null = null
    let scaleTimeoutIds: Map<HTMLButtonElement, ReturnType<typeof setTimeout>> = new Map()
    const processingButtons = new Set<HTMLButtonElement>() // Debounce: track buttons being processed
    let serverReactions: Record<string, number> = {} // Store server reaction counts
    let currentPostId: string | null = null

    /**
     * Get user's reactions (which ones they've clicked)
     */
    function getUserReactions(): Record<string, string[]> {
      try {
        const stored = localStorage.getItem(USER_REACTIONS_KEY)
        return stored ? JSON.parse(stored) : {}
      } catch {
        return {}
      }
    }

    /**
     * Save user's reactions
     */
    function saveUserReactions(userReactions: Record<string, string[]>): void {
      try {
        localStorage.setItem(USER_REACTIONS_KEY, JSON.stringify(userReactions))
      } catch (err) {
        // Handle quota exceeded error
        if (err instanceof DOMException && err.name === 'QuotaExceededError') {
          console.warn('LocalStorage quota exceeded for user reactions')
          // Clear oldest entries
          try {
            const keys = Object.keys(userReactions)
            if (keys.length > 100) {
              const sorted = keys.sort()
              const toKeep = sorted.slice(-50)
              const cleaned: Record<string, string[]> = {}
              toKeep.forEach(key => {
                cleaned[key] = userReactions[key]
              })
              localStorage.setItem(USER_REACTIONS_KEY, JSON.stringify(cleaned))
            }
          } catch (cleanupErr) {
            console.error('Failed to cleanup user reactions:', cleanupErr)
          }
        } else {
          console.error('Failed to save user reactions:', err)
        }
      }
    }

    /**
     * Check if user has already reacted to this post
     */
    function hasUserReacted(postId: string, reactionKey?: string): boolean {
      const userReactions = getUserReactions()
      const postReactions = userReactions[postId] || []
      
      if (reactionKey) {
        return postReactions.includes(reactionKey)
      }
      // If no specific reaction key, check if user has reacted at all
      return postReactions.length > 0
    }

    /**
     * Mark that user has reacted
     */
    function markUserReacted(postId: string, reactionKey: string): void {
      const userReactions = getUserReactions()
      if (!userReactions[postId]) {
        userReactions[postId] = []
      }
      if (!userReactions[postId].includes(reactionKey)) {
        userReactions[postId].push(reactionKey)
        saveUserReactions(userReactions)
      }
    }

    /**
     * Fetch reaction counts from server
     */
    async function fetchReactionCounts(postId: string): Promise<void> {
      try {
        const response = await fetch(`${API_BASE}/${postId}`)
        if (!response.ok) {
          console.warn('Failed to fetch reaction counts:', response.statusText)
          return
        }
        const data = await response.json()
        serverReactions = data.reactions || {}
        
        // Update UI with server counts
        if (reactionButtons) {
          reactionButtons.forEach((button) => {
            const reactionKey = button.dataset.reaction
            if (reactionKey) {
              const count = serverReactions[reactionKey] || 0
              const countElement = button.querySelector<HTMLElement>('[data-count]')
              if (countElement) {
                countElement.textContent = count.toString()
              }
            }
          })
        }
      } catch (error) {
        console.error('Error fetching reaction counts:', error)
        // Continue with empty counts - UI will show 0
      }
    }

    /**
     * Get reaction count from server data
     */
    function getReactionCount(reactionKey: string): number {
      return serverReactions[reactionKey] || 0
    }

    /**
     * Increment reaction on server (only if user hasn't reacted yet)
     */
    async function incrementReaction(
      postId: string,
      reactionKey: string,
    ): Promise<number | null> {
      // Check if user has already reacted to this post
      if (hasUserReacted(postId)) {
        return null // User already reacted, don't increment
      }

      try {
        const response = await fetch(`${API_BASE}/${postId}`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({ reactionKey }),
        })

        if (!response.ok) {
          console.error('Failed to update reaction:', response.statusText)
          return null
        }

        const data = await response.json()
        
        // Update local server reactions cache
        serverReactions = data.reactions || {}
        
        // Mark that user has reacted
        markUserReacted(postId, reactionKey)
        
        return data.count || serverReactions[reactionKey] || 0
      } catch (error) {
        console.error('Error updating reaction:', error)
        return null
      }
    }

    /**
     * Update reaction count display and button state
     */
    function updateReactionDisplay(
      button: HTMLButtonElement,
      count: number,
      isReacted: boolean = false,
    ): void {
      const countElement = button.querySelector<HTMLElement>(
        '[data-count]',
      )
      if (countElement) {
        countElement.textContent = count.toString()
      }

      // Update button state based on whether user has reacted
      if (isReacted) {
        button.disabled = true
        button.classList.add('opacity-60', 'cursor-not-allowed')
        button.classList.remove('hover:bg-muted', 'hover:border-primary/50')
        button.setAttribute('aria-label', button.getAttribute('aria-label') + ' (already reacted)')
      } else {
        button.disabled = false
        button.classList.remove('opacity-60', 'cursor-not-allowed')
        button.classList.add('hover:bg-muted', 'hover:border-primary/50')
      }

      // Visual feedback on click
      if (!isReacted) {
        // Clear any existing timeout for this button
        const existingTimeout = scaleTimeoutIds.get(button)
        if (existingTimeout) {
          clearTimeout(existingTimeout)
        }
        
        button.classList.add('scale-105')
        const scaleTimeout = setTimeout(() => {
          button.classList.remove('scale-105')
          scaleTimeoutIds.delete(button)
        }, 200)
        scaleTimeoutIds.set(button, scaleTimeout)
      }
    }

    /**
     * Initialize reaction counts from server and button states
     */
    async function initializeReactionCounts(): Promise<void> {
      if (!reactionButtons || !currentPostId) return

      // Fetch counts from server
      await fetchReactionCounts(currentPostId)

      // Update button states
      reactionButtons.forEach((button) => {
        const postId = button.dataset.postId
        const reactionKey = button.dataset.reaction

        if (!postId || !reactionKey) return

        const count = getReactionCount(reactionKey)
        const hasReacted = hasUserReacted(postId)
        updateReactionDisplay(button, count, hasReacted)
      })
    }

    /**
     * Handle reaction button click
     */
    async function handleReactionClick(e: Event): Promise<void> {
      const button = e.currentTarget as HTMLButtonElement
      const postId = button.dataset.postId
      const reactionKey = button.dataset.reaction

      if (!postId || !reactionKey) return

      // Debounce: prevent rapid clicks
      if (processingButtons.has(button)) {
        e.preventDefault()
        return
      }

      // Prevent if user has already reacted to this post (any reaction)
      if (hasUserReacted(postId)) {
        e.preventDefault()
        return
      }

      e.preventDefault()
      processingButtons.add(button)
      button.disabled = true

      // Increment reaction on server
      const newCount = await incrementReaction(postId, reactionKey)
      
      if (newCount !== null) {
        // Successfully incremented
        updateReactionDisplay(button, newCount, true)
        
        // Update all button counts from server cache
        if (reactionButtons) {
          reactionButtons.forEach((otherButton) => {
            const otherPostId = otherButton.dataset.postId
            const otherReactionKey = otherButton.dataset.reaction
            
            if (otherPostId && otherReactionKey && otherPostId === postId) {
              const otherCount = getReactionCount(otherReactionKey)
              const countElement = otherButton.querySelector<HTMLElement>('[data-count]')
              if (countElement) {
                countElement.textContent = otherCount.toString()
              }
              
              // Disable all buttons since user has reacted
              if (otherReactionKey !== reactionKey) {
                otherButton.disabled = true
                otherButton.classList.add('opacity-60', 'cursor-not-allowed')
                otherButton.classList.remove('hover:bg-muted', 'hover:border-primary/50')
              }
            }
          })
        }
      } else {
        // User already reacted or server error
        button.disabled = true
        const count = getReactionCount(reactionKey)
        updateReactionDisplay(button, count, true)
      }
      
      // Remove from processing set after a short delay
      setTimeout(() => {
        processingButtons.delete(button)
      }, 300)
    }

    /**
     * Initialize reaction buttons
     */
    function initReactions(): void {
      // Clean up previous listeners
      if (reactionButtons && clickHandler) {
        reactionButtons.forEach((button) => {
          button.removeEventListener('click', clickHandler as EventListener)
        })
      }

      // Find all reaction buttons
      reactionButtons = document.querySelectorAll<HTMLButtonElement>(
        'button[data-reaction][data-post-id]',
      )

      if (reactionButtons.length === 0) return

      // Get post ID from first button
      const firstButton = reactionButtons[0]
      currentPostId = firstButton.dataset.postId || null

      if (!currentPostId) {
        console.error('Post ID not found')
        return
      }

      // Create handler
      clickHandler = handleReactionClick

      // Attach listeners
      reactionButtons.forEach((button) => {
        button.addEventListener('click', clickHandler as EventListener)
      })

      // Initialize counts from server
      initializeReactionCounts()
    }

    /**
     * Cleanup function
     */
    function cleanup(): void {
      // Clear all pending timeouts
      if (timeoutId) {
        clearTimeout(timeoutId)
        timeoutId = null
      }
      
      // Clear all scale animation timeouts
      scaleTimeoutIds.forEach((timeout) => {
        clearTimeout(timeout)
      })
      scaleTimeoutIds.clear()
      
      if (reactionButtons && clickHandler) {
        reactionButtons.forEach((button) => {
          button.removeEventListener('click', clickHandler as EventListener)
        })
        reactionButtons = null
        clickHandler = null
      }
    }

    // Initialize on page load
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initReactions)
    } else {
      initReactions()
    }

    // Re-initialize on Astro view transitions
    document.addEventListener('astro:page-load', () => {
      cleanup()
      timeoutId = setTimeout(initReactions, 0)
    })

    // Cleanup before page swap
    document.addEventListener('astro:before-swap', cleanup)
  })()
</script>

