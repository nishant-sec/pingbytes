---
import { cn } from '@/lib/utils'

interface Props {
  postId: string
  className?: string
}

const { postId, className } = Astro.props
---

<section
  class={cn('flex flex-col gap-3', className)}
  aria-label="Post reactions"
>
  <div class="flex flex-wrap items-center gap-2">
    <button
      type="button"
      data-reaction="clap"
      data-post-id={postId}
      class="group relative flex items-center gap-2 rounded-full bg-muted/60 px-4 py-2 text-sm transition-all hover:bg-muted focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:opacity-60 disabled:cursor-not-allowed"
      aria-label="React with clap"
      title="Clap"
    >
      <span class="text-lg leading-none" aria-hidden="true">ğŸ‘</span>
      <span class="text-xs font-semibold text-foreground" data-count="clap-count">0</span>
    </button>
  </div>
</section>

<script>
  /**
   * Clap-only reactions
   * Logic adapted from merox-main PostReactions (fetch counts, single reaction lock, localStorage tracking)
   */
  ;(() => {
    'use strict'

    const USER_REACTIONS_KEY = 'user-post-reactions'
    const API_BASE = '/api/reactions'

    let reactionButtons = null
    let clickHandler = null
    let timeoutId = null
    let scaleTimeoutIds = new Map()
    const processingButtons = new Set()
    let serverReactions = {}
    let currentPostId = null

    function getUserReactions() {
      try {
        const stored = localStorage.getItem(USER_REACTIONS_KEY)
        return stored ? JSON.parse(stored) : {}
      } catch {
        return {}
      }
    }

    function hasUserReacted(postId, reactionKey) {
      const userReactions = getUserReactions()
      const postReactions = userReactions[postId] || []
      if (reactionKey) return postReactions.includes(reactionKey)
      return postReactions.length > 0
    }

    function markUserReacted(postId, reactionKey) {
      const userReactions = getUserReactions()
      if (!userReactions[postId]) {
        userReactions[postId] = []
      }
      if (!userReactions[postId].includes(reactionKey)) {
        userReactions[postId].push(reactionKey)
        try {
          localStorage.setItem(USER_REACTIONS_KEY, JSON.stringify(userReactions))
        } catch (err) {
          console.warn('Failed to save user reactions', err)
        }
      }
    }

    async function fetchReactionCounts(postId) {
      try {
        const response = await fetch(`${API_BASE}/${postId}`)
        if (!response.ok) {
          console.warn('Failed to fetch reaction counts:', response.statusText)
          return
        }
        const data = await response.json()
        serverReactions = data.reactions || {}

        if (reactionButtons) {
          reactionButtons.forEach((button) => {
            const reactionKey = button.dataset.reaction
            if (reactionKey) {
              const count = serverReactions[reactionKey] || 0
              const countElement =
                button.querySelector('[data-count]')
              if (countElement) {
                countElement.textContent = count.toString()
              }
            }
          })
        }
      } catch (error) {
        console.error('Error fetching reaction counts:', error)
      }
    }

    function getReactionCount(reactionKey) {
      return serverReactions[reactionKey] || 0
    }

    async function incrementReaction(postId, reactionKey) {
      if (hasUserReacted(postId)) return null
      try {
        const response = await fetch(`${API_BASE}/${postId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ reactionKey }),
        })

        if (!response.ok) {
          console.error('Failed to update reaction:', response.statusText)
          return null
        }

        const data = await response.json()
        serverReactions = data.reactions || {}
        markUserReacted(postId, reactionKey)

        return data.count || serverReactions[reactionKey] || 0
      } catch (error) {
        console.error('Error updating reaction:', error)
        return null
      }
    }

    function updateReactionDisplay(button, count, isReacted = false) {
      const countElement = button.querySelector('[data-count]')
      if (countElement) {
        countElement.textContent = count.toString()
      }

      if (isReacted) {
        button.disabled = true
        button.classList.add('opacity-60', 'cursor-not-allowed')
        button.classList.remove('hover:bg-muted')
        button.setAttribute(
          'aria-label',
          (button.getAttribute('aria-label') || '') + ' (already reacted)',
        )
      } else {
        button.disabled = false
        button.classList.remove('opacity-60', 'cursor-not-allowed')
        button.classList.add('hover:bg-muted')
      }

      if (!isReacted) {
        const existingTimeout = scaleTimeoutIds.get(button)
        if (existingTimeout) clearTimeout(existingTimeout)
        button.classList.add('scale-105')
        const scaleTimeout = setTimeout(() => {
          button.classList.remove('scale-105')
          scaleTimeoutIds.delete(button)
        }, 200)
        scaleTimeoutIds.set(button, scaleTimeout)
      }
    }

    async function initializeReactionCounts() {
      if (!reactionButtons || !currentPostId) return

      await fetchReactionCounts(currentPostId)

      reactionButtons.forEach((button) => {
        const postId = button.dataset.postId
        const reactionKey = button.dataset.reaction

        if (!postId || !reactionKey) return

        const count = getReactionCount(reactionKey)
        const hasReacted = hasUserReacted(postId)
        updateReactionDisplay(button, count, hasReacted)
      })
    }

    async function handleReactionClick(e) {
      const button = e.currentTarget
      const postId = button.dataset.postId
      const reactionKey = button.dataset.reaction

      if (!postId || !reactionKey) return

      if (processingButtons.has(button)) {
        e.preventDefault()
        return
      }

      if (hasUserReacted(postId)) {
        e.preventDefault()
        updateReactionDisplay(button, getReactionCount(reactionKey), true)
        return
      }

      e.preventDefault()
      processingButtons.add(button)
      button.disabled = true

      const newCount = await incrementReaction(postId, reactionKey)

      if (newCount !== null) {
        updateReactionDisplay(button, newCount, true)

        if (reactionButtons) {
          reactionButtons.forEach((otherButton) => {
            const otherPostId = otherButton.dataset.postId
            const otherReactionKey = otherButton.dataset.reaction

            if (otherPostId && otherReactionKey && otherPostId === postId) {
              const otherCount = getReactionCount(otherReactionKey)
              const countElement =
                otherButton.querySelector('[data-count]')
              if (countElement) {
                countElement.textContent = otherCount.toString()
              }

              if (otherReactionKey !== reactionKey) {
                otherButton.disabled = true
                otherButton.classList.add('opacity-60', 'cursor-not-allowed')
                otherButton.classList.remove('hover:bg-muted')
              }
            }
          })
        }
      } else {
        button.disabled = true
        const count = getReactionCount(reactionKey)
        updateReactionDisplay(button, count, true)
      }

      setTimeout(() => {
        processingButtons.delete(button)
      }, 300)
    }

    function initReactions() {
      if (reactionButtons && clickHandler) {
        reactionButtons.forEach((button) => {
          button.removeEventListener('click', clickHandler)
        })
      }

      reactionButtons = document.querySelectorAll(
        'button[data-reaction][data-post-id]',
      )

      if (reactionButtons.length === 0) return

      const firstButton = reactionButtons[0]
      currentPostId = firstButton.dataset.postId || null

      if (!currentPostId) {
        console.error('Post ID not found')
        return
      }

      clickHandler = handleReactionClick

      reactionButtons.forEach((button) => {
        button.addEventListener('click', clickHandler)
      })

      initializeReactionCounts()
    }

    function cleanup() {
      if (timeoutId) {
        clearTimeout(timeoutId)
        timeoutId = null
      }

      scaleTimeoutIds.forEach((timeout) => {
        clearTimeout(timeout)
      })
      scaleTimeoutIds.clear()

      if (reactionButtons && clickHandler) {
        reactionButtons.forEach((button) => {
          button.removeEventListener('click', clickHandler)
        })
        reactionButtons = null
        clickHandler = null
      }
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initReactions)
    } else {
      initReactions()
    }

    document.addEventListener('astro:page-load', () => {
      cleanup()
      timeoutId = setTimeout(initReactions, 0)
    })

    document.addEventListener('astro:before-swap', cleanup)
  })()
</script>
