---
import { ScrollArea } from '@/components/ui/scroll-area'
import { getAllWikiPosts } from '@/lib/data-utils'
import WikiSidebarItem from './WikiSidebarItem.astro'
import type { CollectionEntry } from 'astro:content'

// 1. Get current ID safely
const { id } = Astro.params
const currentPostId = (id as string) || ''

// 2. Fetch all posts
const posts = await getAllWikiPosts()

// 3. Define Tree Types
type TreeNode = {
  type: 'file' | 'folder'
  name: string
  path: string
  data?: CollectionEntry<'wiki'>
  children: TreeNode[]
}

// 4. Helper to find or create a folder in a list of nodes
const getOrCreateFolder = (
  nodes: TreeNode[],
  name: string,
  path: string,
): TreeNode => {
  let node = nodes.find((n) => n.name === name && n.type === 'folder')
  if (!node) {
    node = { type: 'folder', name, path, children: [] }
    nodes.push(node)
  }
  return node
}

// 5. Build the Tree
const tree: TreeNode[] = []

posts.forEach((post) => {
  // Split the ID (e.g., "examples/nested/doc") into parts
  const parts = post.id.split('/')
  let currentLevel = tree
  let currentPath = ''

  parts.forEach((part, index) => {
    // Reconstruct the path for folder checking
    currentPath = currentPath ? `${currentPath}/${part}` : part

    if (index === parts.length - 1) {
      // It is a file (last part of the path)
      currentLevel.push({
        type: 'file',
        name: part,
        path: currentPath,
        data: post,
        children: [],
      })
    } else {
      // It is a folder
      const folder = getOrCreateFolder(currentLevel, part, currentPath)
      currentLevel = folder.children
    }
  })
})

// 6. Sort the Tree (Folders first, then Files, Alphabetical)
function sortTree(nodes: TreeNode[]) {
  nodes.sort((a, b) => {
    // Put folders before files
    if (a.type !== b.type) {
      return a.type === 'folder' ? -1 : 1
    }
    // Alphabetical sort by name
    return a.name.localeCompare(b.name)
  })
  
  // Recursively sort children
  nodes.forEach(node => {
    if (node.children.length > 0) {
      sortTree(node.children)
    }
  })
}

sortTree(tree)
---

<div
  id="wiki-sidebar-container"
  class="sticky top-20 col-start-1 row-span-1 ml-auto mr-8 hidden h-[calc(100vh-5rem)] max-w-md xl:block"
>
  <ScrollArea
    client:visible
    className="flex max-h-[calc(100vh-8rem)] flex-col overflow-y-auto"
    data-wiki-sidebar-scroll
  >
    <div class="px-4">
      <ul class="space-y-1">
        {
          tree.map((item) => (
            <WikiSidebarItem item={item} currentId={currentPostId} />
          ))
        }
      </ul>
    </div>
  </ScrollArea>
</div>

<script>
  // Scroll handling logic (keeps active item in view)
  class SidebarState {
    scrollArea: HTMLElement | null = null
    sidebarScrollArea: HTMLElement | null = null

    reset() {
      this.scrollArea = null
      this.sidebarScrollArea = null
    }
  }

  const state = new SidebarState()

  class SidebarScrollMask {
    static update() {
      if (!state.scrollArea || !state.sidebarScrollArea) return

      const { scrollTop, scrollHeight, clientHeight } = state.scrollArea
      const threshold = 5
      const isAtTop = scrollTop <= threshold
      const isAtBottom = scrollTop >= scrollHeight - clientHeight - threshold

      state.sidebarScrollArea.classList.toggle('mask-t-from-90%', !isAtTop)
      state.sidebarScrollArea.classList.toggle('mask-b-from-90%', !isAtBottom)
    }
  }

  class SidebarScroll {
    static toActive() {
      if (!state.scrollArea) return

      // Find the active item (marked by bg-muted in WikiSidebarItem)
      const activeItem = state.scrollArea.querySelector(
        '.bg-muted.text-foreground', 
      )
      
      if (!activeItem) return

      const { top: areaTop, height: areaHeight } =
        state.scrollArea.getBoundingClientRect()
      const { top: itemTop, height: itemHeight } =
        activeItem.getBoundingClientRect()

      const currentItemTop = itemTop - areaTop + state.scrollArea.scrollTop
      const targetScroll = Math.max(
        0,
        Math.min(
          currentItemTop - (areaHeight - itemHeight) / 2,
          state.scrollArea.scrollHeight - state.scrollArea.clientHeight,
        ),
      )

      state.scrollArea.scrollTop = targetScroll
    }
  }

  class SidebarController {
    static init() {
      state.reset()

      const sidebarContainer = document.getElementById('wiki-sidebar-container')
      if (sidebarContainer) {
        state.scrollArea = sidebarContainer.querySelector(
          '[data-radix-scroll-area-viewport]',
        )
        state.sidebarScrollArea = sidebarContainer.querySelector(
          '[data-wiki-sidebar-scroll]',
        )

        if (state.scrollArea) {
          state.scrollArea.addEventListener(
            'scroll',
            SidebarScrollMask.update,
            { passive: true },
          )
        }

        requestAnimationFrame(() => {
          SidebarScroll.toActive()
          setTimeout(SidebarScrollMask.update, 100)
        })
      }
    }

    static cleanup() {
      if (state.scrollArea) {
        state.scrollArea.removeEventListener('scroll', SidebarScrollMask.update)
      }
      state.reset()
    }
  }

  document.addEventListener('astro:page-load', () => SidebarController.init())
  document.addEventListener('astro:after-swap', () => {
    SidebarController.cleanup()
    SidebarController.init()
  })
  document.addEventListener('astro:before-swap', () =>
    SidebarController.cleanup(),
  )
</script>